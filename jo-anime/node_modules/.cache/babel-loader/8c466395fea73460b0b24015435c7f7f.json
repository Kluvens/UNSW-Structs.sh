{"ast":null,"code":"import anime from \"animejs\";\nconst CURRENT = \"#current\";\nconst PREV = \"#prev\";\nconst MORPHED = \"M52 48C103.5 15.5 147.5 13.5 198 47.9999M198 47.9999L196.5 28.5M198 47.9999L176.5 48\";\nconst ARROW = \"M53 74.6504C75.05 74.6504 76.4 74.6504 98 74.6504M98 74.6504L87.5 64M98 74.6504L87.5 87\"; // Node Structure:\n// {\n//     id: Number,\n//     nodeTaget: String,\n//     pathTarget: String\n// }\n\nfunction createSequence(input, type) {\n  const timeline = [];\n\n  if (type === 'append') {\n    const {\n      newNode,\n      nodes\n    } = input; // newNode appears\n\n    timeline.push({\n      targets: newNode.nodeTarget,\n      opacity: 1\n    }); // Current pointer appears\n\n    timeline.push({\n      targets: CURRENT,\n      opacity: 1\n    }); // Current pointer moves into position\n\n    for (const node in nodes) {\n      timeline.push({\n        targets: CURRENT,\n        translateX: node * 100\n      });\n    } // newNode goes to position above current\n\n\n    timeline.push({\n      targets: newNode.nodeTarget,\n      top: '37%',\n      left: (nodes.length - 1) * 100\n    }); // Current pointer disapears\n\n    timeline.push({\n      targets: CURRENT,\n      opacity: 0\n    }); // Arrow path appears\n\n    timeline.push({\n      targets: newNode.pathTarget,\n      opacity: 1\n    }); // Current arrow goes back to beginning\n\n    timeline.push({\n      targets: CURRENT,\n      translateX: 0,\n      duration: 10\n    });\n  } else if (type === 'deleteByIndex') {\n    const {\n      index,\n      deletedNode,\n      shiftedNodes,\n      prevNode\n    } = input; // Current and Prev appears\n\n    timeline.push({\n      targets: [CURRENT, PREV],\n      opacity: 1\n    }); // Curr and Prev loop until it reaches the index\n\n    if (index !== 0) {\n      timeline.push({\n        targets: CURRENT,\n        translateX: 100\n      });\n      console.log(index);\n\n      for (let i = 0; i < index; i++) {\n        timeline.push({\n          targets: PREV,\n          translateX: '+=100'\n        });\n        timeline.push({\n          targets: CURRENT,\n          translateX: '+=100'\n        });\n      } // Morph the arrow into bendy arrow\n\n\n      timeline.push({\n        targets: prevNode.pathTarget,\n        d: [{\n          value: ARROW\n        }, {\n          value: MORPHED\n        }]\n      });\n    } // Vanish the current arrow and the node together\n\n\n    timeline.push({\n      targets: [deletedNode.nodeTarget, CURRENT],\n      opacity: 0\n    }); // Arrow should morph back the same time linked list is shifted\n\n    const playLater = anime({\n      targets: prevNode.pathTarget,\n      d: [{\n        value: MORPHED\n      }, {\n        value: ARROW\n      }],\n      easing: \"spring(1, 80, 10, 0)\",\n      autoplay: false\n    });\n    timeline.push({\n      targets: shiftedNodes.map(n => n.nodeTarget),\n      translateX: \"-=100\",\n      backlog: playLater\n    }); // Current and Prev go back to beginning\n\n    timeline.push({\n      targets: [CURRENT, PREV],\n      translateX: 0\n    });\n  }\n\n  return timeline;\n} // function createDeleteNodeSequence(shiftedNodes, deletedNode, input) {\n//     let currentTimeline = anime.timeline({\n//         duration: 250,\n//         easing: 'easeOutExpo'\n//     })\n//     currentTimeline.add({\n//         targets: \"#current\",\n//         opacity: 1\n//     })\n//     for (let i = 0; i < input; i++) {\n//         currentTimeline.add({\n//             targets: \"#current\",\n//             translateX: i * 100\n//         })\n//     }\n//     const current = document.querySelector(\"#current\")\n//     const deletedDOM = document.querySelector(`#node-${deletedNode.key}`)\n//     currentTimeline.add({\n//         targets: [current, deletedDOM],\n//         opacity: 0\n//     })\n//     const elements = shiftedNodes.map(node => {\n//         return `#node-${node.key}`\n//     })\n//     document.querySelectorAll(elements)\n//     currentTimeline.add({\n//         targets: elements,\n//         translateX: '-=100',\n//         complete: () => deleteNode(deletedNode)\n//     })\n//     currentTimeline.add({\n//         targets: \"#current\",\n//         translateX: 0\n//     })\n// }\n\n\nexport default createSequence;","map":{"version":3,"sources":["/Users/joe/Desktop/structs/Structs.sh/jo-anime/src/createSequence.js"],"names":["anime","CURRENT","PREV","MORPHED","ARROW","createSequence","input","type","timeline","newNode","nodes","push","targets","nodeTarget","opacity","node","translateX","top","left","length","pathTarget","duration","index","deletedNode","shiftedNodes","prevNode","console","log","i","d","value","playLater","easing","autoplay","map","n","backlog"],"mappings":"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","sourcesContent":["import anime from \"animejs\"\n\nconst CURRENT = \"#current\"\nconst PREV = \"#prev\"\nconst MORPHED = \"M52 48C103.5 15.5 147.5 13.5 198 47.9999M198 47.9999L196.5 28.5M198 47.9999L176.5 48\"\nconst ARROW = \"M53 74.6504C75.05 74.6504 76.4 74.6504 98 74.6504M98 74.6504L87.5 64M98 74.6504L87.5 87\"\n\n// Node Structure:\n// {\n//     id: Number,\n//     nodeTaget: String,\n//     pathTarget: String\n// }\n\nfunction createSequence(input, type) {\n\n    const timeline = []\n    if (type === 'append') {\n        const {newNode, nodes} = input\n        // newNode appears\n        timeline.push({\n            targets: newNode.nodeTarget,\n            opacity: 1\n        })\n        // Current pointer appears\n        timeline.push({\n            targets: CURRENT,\n            opacity: 1\n        })\n        // Current pointer moves into position\n        for (const node in nodes) {\n            timeline.push({\n                targets: CURRENT,\n                translateX: node * 100\n            })\n        }\n        // newNode goes to position above current\n        timeline.push({\n            targets: newNode.nodeTarget,\n            top: '37%',\n            left: (nodes.length - 1) * 100\n        })\n        // Current pointer disapears\n        timeline.push({\n            targets: CURRENT,\n            opacity: 0\n        })\n        // Arrow path appears\n        timeline.push({\n            targets: newNode.pathTarget,\n            opacity: 1\n        })\n        // Current arrow goes back to beginning\n        timeline.push({\n            targets: CURRENT,\n            translateX: 0,\n            duration: 10\n        })\n\n    }\n    else if (type === 'deleteByIndex') {\n        const {index, deletedNode, shiftedNodes, prevNode} = input\n        // Current and Prev appears\n        timeline.push({\n            targets: [CURRENT, PREV],\n            opacity: 1\n        })\n        // Curr and Prev loop until it reaches the index\n        if (index !== 0) {\n            timeline.push({\n                targets: CURRENT,\n                translateX: 100\n            })\n            console.log(index)\n            for (let i = 0; i < index; i++) {\n                timeline.push({\n                    targets: PREV,\n                    translateX: '+=100'\n                })\n                timeline.push({\n                    targets: CURRENT,\n                    translateX: '+=100'\n                })\n            }\n            // Morph the arrow into bendy arrow\n            timeline.push({\n                targets: prevNode.pathTarget,\n                d: [\n                    {value: ARROW},\n                    {value: MORPHED}\n                ]\n            })\n        }\n        // Vanish the current arrow and the node together\n        timeline.push({\n            targets: [deletedNode.nodeTarget, CURRENT],\n            opacity: 0\n        })\n        // Arrow should morph back the same time linked list is shifted\n        const playLater = anime({\n            targets: prevNode.pathTarget,\n            d: [\n                {value: MORPHED},\n                {value: ARROW}\n            ],\n            easing: \"spring(1, 80, 10, 0)\",\n            autoplay: false\n        })\n        timeline.push({\n            targets: shiftedNodes.map(n => n.nodeTarget),\n            translateX: \"-=100\",\n            backlog: playLater\n        })\n        // Current and Prev go back to beginning\n        timeline.push({\n            targets: [CURRENT, PREV],\n            translateX: 0\n        })\n\n\n    }\n\n    return timeline\n\n}\n\n// function createDeleteNodeSequence(shiftedNodes, deletedNode, input) {\n//     let currentTimeline = anime.timeline({\n//         duration: 250,\n//         easing: 'easeOutExpo'\n//     })\n//     currentTimeline.add({\n//         targets: \"#current\",\n//         opacity: 1\n//     })\n//     for (let i = 0; i < input; i++) {\n//         currentTimeline.add({\n//             targets: \"#current\",\n//             translateX: i * 100\n//         })\n//     }\n//     const current = document.querySelector(\"#current\")\n//     const deletedDOM = document.querySelector(`#node-${deletedNode.key}`)\n//     currentTimeline.add({\n//         targets: [current, deletedDOM],\n//         opacity: 0\n//     })\n//     const elements = shiftedNodes.map(node => {\n//         return `#node-${node.key}`\n//     })\n//     document.querySelectorAll(elements)\n//     currentTimeline.add({\n//         targets: elements,\n//         translateX: '-=100',\n//         complete: () => deleteNode(deletedNode)\n//     })\n//     currentTimeline.add({\n//         targets: \"#current\",\n//         translateX: 0\n//     })\n// }\n\nexport default createSequence"]},"metadata":{},"sourceType":"module"}